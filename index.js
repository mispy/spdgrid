// Generated by CoffeeScript 1.6.3
(function() {
  var BETRAYAL_GAIN, COOPERATE, DEFECT, Game, Grid, game,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  DEFECT = 0;

  COOPERATE = 1;

  BETRAYAL_GAIN = 1.8;

  window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) {
    return window.setTimeout(callback, 1000 / 60);
  };

  Grid = (function(_super) {
    __extends(Grid, _super);

    function Grid(width, height, generator) {
      var col, x, y, _i, _j, _ref, _ref1;
      this.width = width;
      this.height = height;
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        col = [];
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          col.push(generator(x, y));
        }
        this.push(col);
      }
    }

    return Grid;

  })(Array);

  Game = (function() {
    function Game(canvas) {
      this.reset = __bind(this.reset, this);
      this.togglepause = __bind(this.togglepause, this);
      this.mousemove = __bind(this.mousemove, this);
      this.mouseup = __bind(this.mouseup, this);
      this.mousedown = __bind(this.mousedown, this);
      this.update = __bind(this.update, this);
      this.render = __bind(this.render, this);
      this.renderKeepScore = __bind(this.renderKeepScore, this);
      this.renderScoreless = __bind(this.renderScoreless, this);
      var cell, x, y, _i, _j, _ref, _ref1,
        _this = this;
      this.canvas = canvas;
      this.width = 99;
      this.height = 99;
      this.keepscore = false;
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      $(window).on('resize', function() {
        return delay(function() {
          _this.canvas.width = window.innerWidth;
          return _this.canvas.height = window.innerHeight;
        });
      });
      this.devcanvas = this.canvas.cloneNode();
      this.ctx = this.devcanvas.getContext('2d');
      this.finalctx = this.canvas.getContext('2d');
      this.grid = new Grid(this.width, this.height, function(x, y) {
        var cell;
        cell = {};
        cell.lastlastplayer = COOPERATE;
        cell.lastplayer = COOPERATE;
        cell.player = COOPERATE;
        cell.nextplayer = COOPERATE;
        cell.score = 0;
        return cell;
      });
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          cell = this.grid[x][y];
          cell.adjacencies = [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1], [x - 1, y - 1], [x - 1, y + 1], [x + 1, y - 1], [x + 1, y + 1], [x, y]].reject(function(adj) {
            return adj[0] < 0 || adj[0] >= _this.width || adj[1] < 0 || adj[1] >= _this.height;
          }).map(function(adj) {
            return _this.grid[adj[0]][adj[1]];
          });
        }
      }
      this.reset();
    }

    Game.prototype.play = function(c1, c2) {
      var p1, p2;
      p1 = c1.player;
      p2 = c2.player;
      if (p1 === COOPERATE && p2 === COOPERATE) {
        c1.score += 1;
        return c2.score += 1;
      } else if (p1 === COOPERATE && p2 === DEFECT) {
        return c2.score += BETRAYAL_GAIN;
      } else if (p1 === DEFECT && p2 === COOPERATE) {
        return c1.score += BETRAYAL_GAIN;
      } else {

      }
    };

    Game.prototype.renderScoreless = function() {
      var cell, x, y, _i, _ref, _results;
      this.ctx.fillStyle = "#f5aa44";
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      _results = [];
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            cell = this.grid[x][y];
            if (cell.player === DEFECT && cell.lastplayer === DEFECT) {
              this.ctx.fillStyle = "#000000";
            } else if (cell.player === DEFECT && cell.lastplayer === COOPERATE) {
              this.ctx.fillStyle = "#ff2525";
            } else if (cell.player === COOPERATE && cell.lastplayer === DEFECT) {
              this.ctx.fillStyle = "#00aa44";
            } else {
              continue;
            }
            _results1.push(this.ctx.fillRect(Math.floor(x / this.width * this.canvas.width), Math.floor(y / this.height * this.canvas.height), Math.ceil(this.canvas.width / this.width), Math.ceil(this.canvas.height / this.height)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.colorFromWhite = function(r, g, b, f) {
      return ("rgb(" + (Math.round(255 - (255 - r) * f)) + ",") + ("" + (Math.round(255 - (255 - g) * f)) + ",") + ("" + (Math.round(255 - (255 - b) * f)) + ")");
    };

    Game.prototype.colorFromBlack = function(r, g, b, f) {
      return ("rgb(" + (Math.round(r * f)) + ",") + ("" + (Math.round(g * f)) + ",") + ("" + (Math.round(b * f)) + ")");
    };

    Game.prototype.renderKeepScore = function() {
      var cell, scoreCol, x, y, _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
            cell = this.grid[x][y];
            scoreCol = cell.score / this.totalBestScore;
            if (cell.player === COOPERATE) {
              this.ctx.fillStyle = this.colorFromWhite(245, 170, 68, scoreCol);
            } else {
              this.ctx.fillStyle = this.colorFromBlack(255, 37, 37, scoreCol);
            }
            _results1.push(this.ctx.fillRect(Math.floor(x / this.width * this.canvas.width), Math.floor(y / this.height * this.canvas.height), Math.ceil(this.canvas.width / this.width), Math.ceil(this.canvas.height / this.height)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.render = function() {
      if (this.keepscore) {
        this.renderKeepScore();
      } else {
        this.renderScoreless();
      }
      return this.finalctx.drawImage(this.devcanvas, 0, 0);
    };

    Game.prototype.playAll = function() {
      var adj, cell, row, _i, _len, _ref, _results;
      _ref = this.grid;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        _results.push((function() {
          var _j, _len1, _results1;
          _results1 = [];
          for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
            cell = row[_j];
            _results1.push((function() {
              var _k, _len2, _ref1, _results2;
              _ref1 = cell.adjacencies;
              _results2 = [];
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                adj = _ref1[_k];
                _results2.push(this.play(cell, adj));
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Game.prototype.update = function() {
      var adj, alts, best, cell, cs, ds, row, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
      requestAnimFrame(this.update);
      if (this.paused) {
        return;
      }
      this.playAll();
      this.totalBestScore = 255;
      _ref = this.grid;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        for (_j = 0, _len1 = row.length; _j < _len1; _j++) {
          cell = row[_j];
          best = cell;
          alts = [cell];
          _ref1 = cell.adjacencies;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            adj = _ref1[_k];
            if (adj.score > best.score) {
              best = adj;
              alts = [best];
            } else if (adj.score === best.score) {
              alts.push(adj);
            }
          }
          if (best.score > this.totalBestScore) {
            this.totalBestScore = best.score;
          }
          if (alts.length > 1) {
            cs = alts.find_all(function(adj) {
              return adj.player === COOPERATE;
            });
            ds = alts.find_all(function(adj) {
              return adj.player === DEFECT;
            });
            if (ds.length > cs.length) {
              cell.nextplayer = DEFECT;
            } else if (cs.length > ds.length) {
              cell.nextplayer = COOPERATE;
            } else {
              cell.nextplayer = cell.player;
            }
          } else {
            cell.nextplayer = best.player;
          }
        }
      }
      _ref2 = this.grid;
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        row = _ref2[_l];
        for (_m = 0, _len4 = row.length; _m < _len4; _m++) {
          cell = row[_m];
          if (this.keepscore) {
            if (this.totalBestScore > 255) {
              cell.score = Math.round(cell.score / this.totalBestScore * 255);
            }
          } else {
            cell.score = 0;
          }
          cell.lastlastplayer = cell.lastplayer;
          cell.lastplayer = cell.player;
          cell.player = cell.nextplayer;
        }
      }
      return this.render();
    };

    Game.prototype.mousedown = function(ev) {
      this.mousing = true;
      this.mousemove(ev);
      return false;
    };

    Game.prototype.mouseup = function(ev) {
      return this.mousing = false;
    };

    Game.prototype.mousemove = function(ev) {
      var cx, cy, x, y;
      if (!this.mousing) {
        return;
      }
      cx = ev.pageX - $('canvas').offset().left;
      cy = ev.pageY - $('canvas').offset().top;
      x = Math.floor(this.width * (cx / this.canvas.width));
      y = Math.floor(this.height * (cy / this.canvas.height));
      this.grid[x][y].player = DEFECT;
      return this.render();
    };

    Game.prototype.togglepause = function(paused) {
      this.paused = paused != null ? paused : !this.paused;
      if (this.paused) {
        return $('.pause').addClass('btn-success');
      } else {
        return $('.pause').removeClass('btn-success');
      }
    };

    Game.prototype.reset = function() {
      "Reset grid to full cooperation.";
      var x, y, _i, _j, _ref, _ref1;
      for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          this.grid[x][y].player = COOPERATE;
        }
      }
      return this.render();
    };

    Game.prototype.events = function() {
      var _this = this;
      $('.pause').click(function() {
        return _this.togglepause();
      });
      $('.reset').click(this.reset);
      $('canvas').mousedown(this.mousedown);
      $('canvas').mouseup(this.mouseup);
      $('canvas').mousemove(this.mousemove);
      $('.bgain').val(BETRAYAL_GAIN);
      $('.bgain').on('keyup mouseup', function() {
        return BETRAYAL_GAIN = parseFloat($('.bgain').val());
      });
      $('.keepscore').prop('checked', this.keepscore);
      $('.keepscore').on('click', function() {
        _this.keepscore = $('.keepscore').prop('checked');
        return true;
      });
      $('.about').click(function() {
        if (!_this.paused) {
          _this.aboutpaused = true;
        }
        return _this.togglepause(true);
      });
      return $('#about').on('hidden.bs.modal', function() {
        if (_this.aboutpaused) {
          _this.togglepause(false);
        }
        return _this.aboutpaused = false;
      });
    };

    return Game;

  })();

  game = new Game(document.getElementsByTagName('canvas')[0]);

  game.events();

  game.update();

}).call(this);
